// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
)

type ActionResponse struct {
	ActionPerformed string `json:"action_performed" url:"action_performed"`
	status          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionResponse) GetActionPerformed() string {
	if a == nil {
		return ""
	}
	return a.ActionPerformed
}

func (a *ActionResponse) Status() string {
	return a.status
}

func (a *ActionResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionResponse) UnmarshalJSON(data []byte) error {
	type embed ActionResponse
	var unmarshaler = struct {
		embed
		Status string `json:"status"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActionResponse(unmarshaler.embed)
	if unmarshaler.Status != "success" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "success", unmarshaler.Status)
	}
	a.status = unmarshaler.Status
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "status")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionResponse) MarshalJSON() ([]byte, error) {
	type embed ActionResponse
	var marshaler = struct {
		embed
		Status string `json:"status"`
	}{
		embed:  embed(*a),
		Status: "success",
	}
	return json.Marshal(marshaler)
}

func (a *ActionResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Browser Info result
type BrowserInfoResult struct {
	// User agent
	UserAgent string `json:"user_agent" url:"user_agent"`
	// Browser CDP URL
	CdpUrl string `json:"cdp_url" url:"cdp_url"`
	// VNC URL
	VncUrl string `json:"vnc_url" url:"vnc_url"`
	// Viewport size
	Viewport *BrowserViewport `json:"viewport,omitempty" url:"viewport,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BrowserInfoResult) GetUserAgent() string {
	if b == nil {
		return ""
	}
	return b.UserAgent
}

func (b *BrowserInfoResult) GetCdpUrl() string {
	if b == nil {
		return ""
	}
	return b.CdpUrl
}

func (b *BrowserInfoResult) GetVncUrl() string {
	if b == nil {
		return ""
	}
	return b.VncUrl
}

func (b *BrowserInfoResult) GetViewport() *BrowserViewport {
	if b == nil {
		return nil
	}
	return b.Viewport
}

func (b *BrowserInfoResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BrowserInfoResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BrowserInfoResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrowserInfoResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrowserInfoResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrowserViewport struct {
	// Viewport width
	Width int `json:"width" url:"width"`
	// Viewport height
	Height int `json:"height" url:"height"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BrowserViewport) GetWidth() int {
	if b == nil {
		return 0
	}
	return b.Width
}

func (b *BrowserViewport) GetHeight() int {
	if b == nil {
		return 0
	}
	return b.Height
}

func (b *BrowserViewport) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BrowserViewport) UnmarshalJSON(data []byte) error {
	type unmarshaler BrowserViewport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrowserViewport(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrowserViewport) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Button string

const (
	ButtonLeft   Button = "left"
	ButtonRight  Button = "right"
	ButtonMiddle Button = "middle"
)

func NewButtonFromString(s string) (Button, error) {
	switch s {
	case "left":
		return ButtonLeft, nil
	case "right":
		return ButtonRight, nil
	case "middle":
		return ButtonMiddle, nil
	}
	var t Button
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b Button) Ptr() *Button {
	return &b
}

type ClickAction struct {
	X         *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y         *float64 `json:"y,omitempty" url:"y,omitempty"`
	Button    *Button  `json:"button,omitempty" url:"button,omitempty"`
	NumClicks *int     `json:"num_clicks,omitempty" url:"num_clicks,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClickAction) GetX() *float64 {
	if c == nil {
		return nil
	}
	return c.X
}

func (c *ClickAction) GetY() *float64 {
	if c == nil {
		return nil
	}
	return c.Y
}

func (c *ClickAction) GetButton() *Button {
	if c == nil {
		return nil
	}
	return c.Button
}

func (c *ClickAction) GetNumClicks() *int {
	if c == nil {
		return nil
	}
	return c.NumClicks
}

func (c *ClickAction) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClickAction) UnmarshalJSON(data []byte) error {
	type unmarshaler ClickAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClickAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClickAction) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DoubleClickAction struct {
	X *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y *float64 `json:"y,omitempty" url:"y,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DoubleClickAction) GetX() *float64 {
	if d == nil {
		return nil
	}
	return d.X
}

func (d *DoubleClickAction) GetY() *float64 {
	if d == nil {
		return nil
	}
	return d.Y
}

func (d *DoubleClickAction) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleClickAction) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleClickAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleClickAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DoubleClickAction) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DragToAction struct {
	// Target x-coordinate for drag
	X float64 `json:"x" url:"x"`
	// Target y-coordinate for drag
	Y float64 `json:"y" url:"y"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DragToAction) GetX() float64 {
	if d == nil {
		return 0
	}
	return d.X
}

func (d *DragToAction) GetY() float64 {
	if d == nil {
		return 0
	}
	return d.Y
}

func (d *DragToAction) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DragToAction) UnmarshalJSON(data []byte) error {
	type unmarshaler DragToAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DragToAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DragToAction) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type HotkeyAction struct {
	Keys []string `json:"keys,omitempty" url:"keys,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HotkeyAction) GetKeys() []string {
	if h == nil {
		return nil
	}
	return h.Keys
}

func (h *HotkeyAction) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HotkeyAction) UnmarshalJSON(data []byte) error {
	type unmarshaler HotkeyAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HotkeyAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HotkeyAction) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type KeyDownAction struct {
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyDownAction) GetKey() string {
	if k == nil {
		return ""
	}
	return k.Key
}

func (k *KeyDownAction) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyDownAction) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyDownAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyDownAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyDownAction) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type KeyUpAction struct {
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyUpAction) GetKey() string {
	if k == nil {
		return ""
	}
	return k.Key
}

func (k *KeyUpAction) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyUpAction) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyUpAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyUpAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyUpAction) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type MouseDownAction struct {
	Button *Button `json:"button,omitempty" url:"button,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MouseDownAction) GetButton() *Button {
	if m == nil {
		return nil
	}
	return m.Button
}

func (m *MouseDownAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MouseDownAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MouseDownAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MouseDownAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MouseDownAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MouseUpAction struct {
	Button *Button `json:"button,omitempty" url:"button,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MouseUpAction) GetButton() *Button {
	if m == nil {
		return nil
	}
	return m.Button
}

func (m *MouseUpAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MouseUpAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MouseUpAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MouseUpAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MouseUpAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MoveToAction struct {
	// Target x-coordinate
	X float64 `json:"x" url:"x"`
	// Target y-coordinate
	Y float64 `json:"y" url:"y"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MoveToAction) GetX() float64 {
	if m == nil {
		return 0
	}
	return m.X
}

func (m *MoveToAction) GetY() float64 {
	if m == nil {
		return 0
	}
	return m.Y
}

func (m *MoveToAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MoveToAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MoveToAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MoveToAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MoveToAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PressAction struct {
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PressAction) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *PressAction) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PressAction) UnmarshalJSON(data []byte) error {
	type unmarshaler PressAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PressAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PressAction) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResponseBrowserInfoResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *BrowserInfoResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseBrowserInfoResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseBrowserInfoResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseBrowserInfoResult) GetData() *BrowserInfoResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseBrowserInfoResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseBrowserInfoResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseBrowserInfoResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseBrowserInfoResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseBrowserInfoResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RightClickAction struct {
	X *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y *float64 `json:"y,omitempty" url:"y,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RightClickAction) GetX() *float64 {
	if r == nil {
		return nil
	}
	return r.X
}

func (r *RightClickAction) GetY() *float64 {
	if r == nil {
		return nil
	}
	return r.Y
}

func (r *RightClickAction) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RightClickAction) UnmarshalJSON(data []byte) error {
	type unmarshaler RightClickAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RightClickAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RightClickAction) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ScrollAction struct {
	Dx *int `json:"dx,omitempty" url:"dx,omitempty"`
	Dy *int `json:"dy,omitempty" url:"dy,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScrollAction) GetDx() *int {
	if s == nil {
		return nil
	}
	return s.Dx
}

func (s *ScrollAction) GetDy() *int {
	if s == nil {
		return nil
	}
	return s.Dy
}

func (s *ScrollAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScrollAction) UnmarshalJSON(data []byte) error {
	type unmarshaler ScrollAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScrollAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScrollAction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypingAction struct {
	Text string `json:"text" url:"text"`
	// Use clipboard for better character support (recommended for special/ASCII characters)
	UseClipboard *bool `json:"use_clipboard,omitempty" url:"use_clipboard,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TypingAction) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TypingAction) GetUseClipboard() *bool {
	if t == nil {
		return nil
	}
	return t.UseClipboard
}

func (t *TypingAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypingAction) UnmarshalJSON(data []byte) error {
	type unmarshaler TypingAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypingAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TypingAction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Action struct {
	ActionType  string
	MoveTo      *MoveToAction
	Click       *ClickAction
	MouseDown   *MouseDownAction
	MouseUp     *MouseUpAction
	RightClick  *RightClickAction
	DoubleClick *DoubleClickAction
	DragTo      *DragToAction
	Scroll      *ScrollAction
	Typing      *TypingAction
	Press       *PressAction
	KeyDown     *KeyDownAction
	KeyUp       *KeyUpAction
	Hotkey      *HotkeyAction
}

func NewActionFromMoveTo(value *MoveToAction) *Action {
	return &Action{ActionType: "MOVE_TO", MoveTo: value}
}

func NewActionFromClick(value *ClickAction) *Action {
	return &Action{ActionType: "CLICK", Click: value}
}

func NewActionFromMouseDown(value *MouseDownAction) *Action {
	return &Action{ActionType: "MOUSE_DOWN", MouseDown: value}
}

func NewActionFromMouseUp(value *MouseUpAction) *Action {
	return &Action{ActionType: "MOUSE_UP", MouseUp: value}
}

func NewActionFromRightClick(value *RightClickAction) *Action {
	return &Action{ActionType: "RIGHT_CLICK", RightClick: value}
}

func NewActionFromDoubleClick(value *DoubleClickAction) *Action {
	return &Action{ActionType: "DOUBLE_CLICK", DoubleClick: value}
}

func NewActionFromDragTo(value *DragToAction) *Action {
	return &Action{ActionType: "DRAG_TO", DragTo: value}
}

func NewActionFromScroll(value *ScrollAction) *Action {
	return &Action{ActionType: "SCROLL", Scroll: value}
}

func NewActionFromTyping(value *TypingAction) *Action {
	return &Action{ActionType: "TYPING", Typing: value}
}

func NewActionFromPress(value *PressAction) *Action {
	return &Action{ActionType: "PRESS", Press: value}
}

func NewActionFromKeyDown(value *KeyDownAction) *Action {
	return &Action{ActionType: "KEY_DOWN", KeyDown: value}
}

func NewActionFromKeyUp(value *KeyUpAction) *Action {
	return &Action{ActionType: "KEY_UP", KeyUp: value}
}

func NewActionFromHotkey(value *HotkeyAction) *Action {
	return &Action{ActionType: "HOTKEY", Hotkey: value}
}

func (a *Action) GetActionType() string {
	if a == nil {
		return ""
	}
	return a.ActionType
}

func (a *Action) GetMoveTo() *MoveToAction {
	if a == nil {
		return nil
	}
	return a.MoveTo
}

func (a *Action) GetClick() *ClickAction {
	if a == nil {
		return nil
	}
	return a.Click
}

func (a *Action) GetMouseDown() *MouseDownAction {
	if a == nil {
		return nil
	}
	return a.MouseDown
}

func (a *Action) GetMouseUp() *MouseUpAction {
	if a == nil {
		return nil
	}
	return a.MouseUp
}

func (a *Action) GetRightClick() *RightClickAction {
	if a == nil {
		return nil
	}
	return a.RightClick
}

func (a *Action) GetDoubleClick() *DoubleClickAction {
	if a == nil {
		return nil
	}
	return a.DoubleClick
}

func (a *Action) GetDragTo() *DragToAction {
	if a == nil {
		return nil
	}
	return a.DragTo
}

func (a *Action) GetScroll() *ScrollAction {
	if a == nil {
		return nil
	}
	return a.Scroll
}

func (a *Action) GetTyping() *TypingAction {
	if a == nil {
		return nil
	}
	return a.Typing
}

func (a *Action) GetPress() *PressAction {
	if a == nil {
		return nil
	}
	return a.Press
}

func (a *Action) GetKeyDown() *KeyDownAction {
	if a == nil {
		return nil
	}
	return a.KeyDown
}

func (a *Action) GetKeyUp() *KeyUpAction {
	if a == nil {
		return nil
	}
	return a.KeyUp
}

func (a *Action) GetHotkey() *HotkeyAction {
	if a == nil {
		return nil
	}
	return a.Hotkey
}

func (a *Action) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ActionType string `json:"action_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.ActionType = unmarshaler.ActionType
	if unmarshaler.ActionType == "" {
		return fmt.Errorf("%T did not include discriminant action_type", a)
	}
	switch unmarshaler.ActionType {
	case "MOVE_TO":
		value := new(MoveToAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MoveTo = value
	case "CLICK":
		value := new(ClickAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Click = value
	case "MOUSE_DOWN":
		value := new(MouseDownAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MouseDown = value
	case "MOUSE_UP":
		value := new(MouseUpAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MouseUp = value
	case "RIGHT_CLICK":
		value := new(RightClickAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.RightClick = value
	case "DOUBLE_CLICK":
		value := new(DoubleClickAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.DoubleClick = value
	case "DRAG_TO":
		value := new(DragToAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.DragTo = value
	case "SCROLL":
		value := new(ScrollAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Scroll = value
	case "TYPING":
		value := new(TypingAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Typing = value
	case "PRESS":
		value := new(PressAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Press = value
	case "KEY_DOWN":
		value := new(KeyDownAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.KeyDown = value
	case "KEY_UP":
		value := new(KeyUpAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.KeyUp = value
	case "HOTKEY":
		value := new(HotkeyAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Hotkey = value
	}
	return nil
}

func (a Action) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.ActionType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.ActionType, a)
	case "MOVE_TO":
		return internal.MarshalJSONWithExtraProperty(a.MoveTo, "action_type", "MOVE_TO")
	case "CLICK":
		return internal.MarshalJSONWithExtraProperty(a.Click, "action_type", "CLICK")
	case "MOUSE_DOWN":
		return internal.MarshalJSONWithExtraProperty(a.MouseDown, "action_type", "MOUSE_DOWN")
	case "MOUSE_UP":
		return internal.MarshalJSONWithExtraProperty(a.MouseUp, "action_type", "MOUSE_UP")
	case "RIGHT_CLICK":
		return internal.MarshalJSONWithExtraProperty(a.RightClick, "action_type", "RIGHT_CLICK")
	case "DOUBLE_CLICK":
		return internal.MarshalJSONWithExtraProperty(a.DoubleClick, "action_type", "DOUBLE_CLICK")
	case "DRAG_TO":
		return internal.MarshalJSONWithExtraProperty(a.DragTo, "action_type", "DRAG_TO")
	case "SCROLL":
		return internal.MarshalJSONWithExtraProperty(a.Scroll, "action_type", "SCROLL")
	case "TYPING":
		return internal.MarshalJSONWithExtraProperty(a.Typing, "action_type", "TYPING")
	case "PRESS":
		return internal.MarshalJSONWithExtraProperty(a.Press, "action_type", "PRESS")
	case "KEY_DOWN":
		return internal.MarshalJSONWithExtraProperty(a.KeyDown, "action_type", "KEY_DOWN")
	case "KEY_UP":
		return internal.MarshalJSONWithExtraProperty(a.KeyUp, "action_type", "KEY_UP")
	case "HOTKEY":
		return internal.MarshalJSONWithExtraProperty(a.Hotkey, "action_type", "HOTKEY")
	}
}

type ActionVisitor interface {
	VisitMoveTo(*MoveToAction) error
	VisitClick(*ClickAction) error
	VisitMouseDown(*MouseDownAction) error
	VisitMouseUp(*MouseUpAction) error
	VisitRightClick(*RightClickAction) error
	VisitDoubleClick(*DoubleClickAction) error
	VisitDragTo(*DragToAction) error
	VisitScroll(*ScrollAction) error
	VisitTyping(*TypingAction) error
	VisitPress(*PressAction) error
	VisitKeyDown(*KeyDownAction) error
	VisitKeyUp(*KeyUpAction) error
	VisitHotkey(*HotkeyAction) error
}

func (a *Action) Accept(visitor ActionVisitor) error {
	switch a.ActionType {
	default:
		return fmt.Errorf("invalid type %s in %T", a.ActionType, a)
	case "MOVE_TO":
		return visitor.VisitMoveTo(a.MoveTo)
	case "CLICK":
		return visitor.VisitClick(a.Click)
	case "MOUSE_DOWN":
		return visitor.VisitMouseDown(a.MouseDown)
	case "MOUSE_UP":
		return visitor.VisitMouseUp(a.MouseUp)
	case "RIGHT_CLICK":
		return visitor.VisitRightClick(a.RightClick)
	case "DOUBLE_CLICK":
		return visitor.VisitDoubleClick(a.DoubleClick)
	case "DRAG_TO":
		return visitor.VisitDragTo(a.DragTo)
	case "SCROLL":
		return visitor.VisitScroll(a.Scroll)
	case "TYPING":
		return visitor.VisitTyping(a.Typing)
	case "PRESS":
		return visitor.VisitPress(a.Press)
	case "KEY_DOWN":
		return visitor.VisitKeyDown(a.KeyDown)
	case "KEY_UP":
		return visitor.VisitKeyUp(a.KeyUp)
	case "HOTKEY":
		return visitor.VisitHotkey(a.Hotkey)
	}
}

func (a *Action) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.MoveTo != nil {
		fields = append(fields, "MOVE_TO")
	}
	if a.Click != nil {
		fields = append(fields, "CLICK")
	}
	if a.MouseDown != nil {
		fields = append(fields, "MOUSE_DOWN")
	}
	if a.MouseUp != nil {
		fields = append(fields, "MOUSE_UP")
	}
	if a.RightClick != nil {
		fields = append(fields, "RIGHT_CLICK")
	}
	if a.DoubleClick != nil {
		fields = append(fields, "DOUBLE_CLICK")
	}
	if a.DragTo != nil {
		fields = append(fields, "DRAG_TO")
	}
	if a.Scroll != nil {
		fields = append(fields, "SCROLL")
	}
	if a.Typing != nil {
		fields = append(fields, "TYPING")
	}
	if a.Press != nil {
		fields = append(fields, "PRESS")
	}
	if a.KeyDown != nil {
		fields = append(fields, "KEY_DOWN")
	}
	if a.KeyUp != nil {
		fields = append(fields, "KEY_UP")
	}
	if a.Hotkey != nil {
		fields = append(fields, "HOTKEY")
	}
	if len(fields) == 0 {
		if a.ActionType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.ActionType)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.ActionType != "" {
		field := fields[0]
		if a.ActionType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.ActionType,
				a,
			)
		}
	}
	return nil
}
