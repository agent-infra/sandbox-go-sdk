// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
)

type NodeJsExecuteRequest struct {
	// JavaScript code to execute
	Code string `json:"code" url:"-"`
	// Execution timeout in seconds
	Timeout *int `json:"timeout,omitempty" url:"-"`
	// Standard input for the process
	Stdin *string `json:"stdin,omitempty" url:"-"`
	// Additional files to create in execution directory
	Files map[string]*string `json:"files,omitempty" url:"-"`
}

type NodeJsExecuteResponse struct {
	// Language that was executed (always 'javascript')
	// Execution status: ok, error, or timeout
	Status string `json:"status" url:"status"`
	// Execution count
	ExecutionCount *int `json:"execution_count,omitempty" url:"execution_count,omitempty"`
	// List of execution outputs
	Outputs []*NodeJsOutput `json:"outputs,omitempty" url:"outputs,omitempty"`
	// Code that was executed
	Code string `json:"code" url:"code"`
	// Standard output
	Stdout *string `json:"stdout,omitempty" url:"stdout,omitempty"`
	// Standard error
	Stderr *string `json:"stderr,omitempty" url:"stderr,omitempty"`
	// Process exit code
	ExitCode int `json:"exit_code" url:"exit_code"`
	language string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NodeJsExecuteResponse) GetStatus() string {
	if n == nil {
		return ""
	}
	return n.Status
}

func (n *NodeJsExecuteResponse) GetExecutionCount() *int {
	if n == nil {
		return nil
	}
	return n.ExecutionCount
}

func (n *NodeJsExecuteResponse) GetOutputs() []*NodeJsOutput {
	if n == nil {
		return nil
	}
	return n.Outputs
}

func (n *NodeJsExecuteResponse) GetCode() string {
	if n == nil {
		return ""
	}
	return n.Code
}

func (n *NodeJsExecuteResponse) GetStdout() *string {
	if n == nil {
		return nil
	}
	return n.Stdout
}

func (n *NodeJsExecuteResponse) GetStderr() *string {
	if n == nil {
		return nil
	}
	return n.Stderr
}

func (n *NodeJsExecuteResponse) GetExitCode() int {
	if n == nil {
		return 0
	}
	return n.ExitCode
}

func (n *NodeJsExecuteResponse) Language() string {
	return n.language
}

func (n *NodeJsExecuteResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NodeJsExecuteResponse) UnmarshalJSON(data []byte) error {
	type embed NodeJsExecuteResponse
	var unmarshaler = struct {
		embed
		Language string `json:"language"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NodeJsExecuteResponse(unmarshaler.embed)
	if unmarshaler.Language != "javascript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "javascript", unmarshaler.Language)
	}
	n.language = unmarshaler.Language
	extraProperties, err := internal.ExtractExtraProperties(data, *n, "language")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NodeJsExecuteResponse) MarshalJSON() ([]byte, error) {
	type embed NodeJsExecuteResponse
	var marshaler = struct {
		embed
		Language string `json:"language"`
	}{
		embed:    embed(*n),
		Language: "javascript",
	}
	return json.Marshal(marshaler)
}

func (n *NodeJsExecuteResponse) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NodeJsOutput struct {
	// Type of output: stream, error, or execute_result
	OutputType string `json:"output_type" url:"output_type"`
	// Stream name (stdout/stderr) for stream outputs
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Text content for stream outputs
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// Error name for error outputs
	Ename *string `json:"ename,omitempty" url:"ename,omitempty"`
	// Error value for error outputs
	Evalue *string `json:"evalue,omitempty" url:"evalue,omitempty"`
	// Error traceback for error outputs
	Traceback []string `json:"traceback,omitempty" url:"traceback,omitempty"`
	// Data for execute_result outputs
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Metadata for outputs
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NodeJsOutput) GetOutputType() string {
	if n == nil {
		return ""
	}
	return n.OutputType
}

func (n *NodeJsOutput) GetName() *string {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NodeJsOutput) GetText() *string {
	if n == nil {
		return nil
	}
	return n.Text
}

func (n *NodeJsOutput) GetEname() *string {
	if n == nil {
		return nil
	}
	return n.Ename
}

func (n *NodeJsOutput) GetEvalue() *string {
	if n == nil {
		return nil
	}
	return n.Evalue
}

func (n *NodeJsOutput) GetTraceback() []string {
	if n == nil {
		return nil
	}
	return n.Traceback
}

func (n *NodeJsOutput) GetData() map[string]interface{} {
	if n == nil {
		return nil
	}
	return n.Data
}

func (n *NodeJsOutput) GetMetadata() map[string]interface{} {
	if n == nil {
		return nil
	}
	return n.Metadata
}

func (n *NodeJsOutput) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NodeJsOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler NodeJsOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NodeJsOutput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NodeJsOutput) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NodeJS runtime information model
type NodeJsRuntimeInfo struct {
	// Node.js version
	NodeVersion string `json:"node_version" url:"node_version"`
	// npm version
	NpmVersion string `json:"npm_version" url:"npm_version"`
	// List of supported languages
	SupportedLanguages []string `json:"supported_languages,omitempty" url:"supported_languages,omitempty"`
	// Service description
	Description string `json:"description" url:"description"`
	// Runtime directory path
	RuntimeDirectory *string `json:"runtime_directory,omitempty" url:"runtime_directory,omitempty"`
	// Error message if runtime info retrieval failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NodeJsRuntimeInfo) GetNodeVersion() string {
	if n == nil {
		return ""
	}
	return n.NodeVersion
}

func (n *NodeJsRuntimeInfo) GetNpmVersion() string {
	if n == nil {
		return ""
	}
	return n.NpmVersion
}

func (n *NodeJsRuntimeInfo) GetSupportedLanguages() []string {
	if n == nil {
		return nil
	}
	return n.SupportedLanguages
}

func (n *NodeJsRuntimeInfo) GetDescription() string {
	if n == nil {
		return ""
	}
	return n.Description
}

func (n *NodeJsRuntimeInfo) GetRuntimeDirectory() *string {
	if n == nil {
		return nil
	}
	return n.RuntimeDirectory
}

func (n *NodeJsRuntimeInfo) GetError() *string {
	if n == nil {
		return nil
	}
	return n.Error
}

func (n *NodeJsRuntimeInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NodeJsRuntimeInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NodeJsRuntimeInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NodeJsRuntimeInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NodeJsRuntimeInfo) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type ResponseNodeJsExecuteResponse struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *NodeJsExecuteResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseNodeJsExecuteResponse) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseNodeJsExecuteResponse) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseNodeJsExecuteResponse) GetData() *NodeJsExecuteResponse {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseNodeJsExecuteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseNodeJsExecuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseNodeJsExecuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseNodeJsExecuteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseNodeJsExecuteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseNodeJsRuntimeInfo struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *NodeJsRuntimeInfo `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseNodeJsRuntimeInfo) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseNodeJsRuntimeInfo) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseNodeJsRuntimeInfo) GetData() *NodeJsRuntimeInfo {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseNodeJsRuntimeInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseNodeJsRuntimeInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseNodeJsRuntimeInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseNodeJsRuntimeInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseNodeJsRuntimeInfo) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
