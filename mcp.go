// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
)

type Annotations struct {
	Audience []AnnotationsAudienceItem `json:"audience,omitempty" url:"audience,omitempty"`
	Priority *float64                  `json:"priority,omitempty" url:"priority,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (a *Annotations) GetAudience() []AnnotationsAudienceItem {
	if a == nil {
		return nil
	}
	return a.Audience
}

func (a *Annotations) GetPriority() *float64 {
	if a == nil {
		return nil
	}
	return a.Priority
}

func (a *Annotations) GetExtraProperties() map[string]interface{} {
	return a.ExtraProperties
}

func (a *Annotations) UnmarshalJSON(data []byte) error {
	type embed Annotations
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Annotations(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.ExtraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Annotations) MarshalJSON() ([]byte, error) {
	type embed Annotations
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, a.ExtraProperties)
}

func (a *Annotations) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnnotationsAudienceItem string

const (
	AnnotationsAudienceItemUser      AnnotationsAudienceItem = "user"
	AnnotationsAudienceItemAssistant AnnotationsAudienceItem = "assistant"
)

func NewAnnotationsAudienceItemFromString(s string) (AnnotationsAudienceItem, error) {
	switch s {
	case "user":
		return AnnotationsAudienceItemUser, nil
	case "assistant":
		return AnnotationsAudienceItemAssistant, nil
	}
	var t AnnotationsAudienceItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnnotationsAudienceItem) Ptr() *AnnotationsAudienceItem {
	return &a
}

// Audio content for a message.
type AudioContent struct {
	Data        string                 `json:"data" url:"data"`
	MimeType    string                 `json:"mimeType" url:"mimeType"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (a *AudioContent) GetData() string {
	if a == nil {
		return ""
	}
	return a.Data
}

func (a *AudioContent) GetMimeType() string {
	if a == nil {
		return ""
	}
	return a.MimeType
}

func (a *AudioContent) GetAnnotations() *Annotations {
	if a == nil {
		return nil
	}
	return a.Annotations
}

func (a *AudioContent) GetMeta() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Meta
}

func (a *AudioContent) GetExtraProperties() map[string]interface{} {
	return a.ExtraProperties
}

func (a *AudioContent) UnmarshalJSON(data []byte) error {
	type embed AudioContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AudioContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.ExtraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudioContent) MarshalJSON() ([]byte, error) {
	type embed AudioContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, a.ExtraProperties)
}

func (a *AudioContent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Binary contents of a resource.
type BlobResourceContents struct {
	Uri      string                 `json:"uri" url:"uri"`
	MimeType *string                `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Meta     map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	Blob     string                 `json:"blob" url:"blob"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (b *BlobResourceContents) GetUri() string {
	if b == nil {
		return ""
	}
	return b.Uri
}

func (b *BlobResourceContents) GetMimeType() *string {
	if b == nil {
		return nil
	}
	return b.MimeType
}

func (b *BlobResourceContents) GetMeta() map[string]interface{} {
	if b == nil {
		return nil
	}
	return b.Meta
}

func (b *BlobResourceContents) GetBlob() string {
	if b == nil {
		return ""
	}
	return b.Blob
}

func (b *BlobResourceContents) GetExtraProperties() map[string]interface{} {
	return b.ExtraProperties
}

func (b *BlobResourceContents) UnmarshalJSON(data []byte) error {
	type embed BlobResourceContents
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BlobResourceContents(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.ExtraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BlobResourceContents) MarshalJSON() ([]byte, error) {
	type embed BlobResourceContents
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, b.ExtraProperties)
}

func (b *BlobResourceContents) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The server's response to a tool call.
type CallToolResult struct {
	Meta              map[string]interface{}       `json:"_meta,omitempty" url:"_meta,omitempty"`
	Content           []*CallToolResultContentItem `json:"content,omitempty" url:"content,omitempty"`
	StructuredContent map[string]interface{}       `json:"structuredContent,omitempty" url:"structuredContent,omitempty"`
	IsError           *bool                        `json:"isError,omitempty" url:"isError,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *CallToolResult) GetMeta() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Meta
}

func (c *CallToolResult) GetContent() []*CallToolResultContentItem {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *CallToolResult) GetStructuredContent() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.StructuredContent
}

func (c *CallToolResult) GetIsError() *bool {
	if c == nil {
		return nil
	}
	return c.IsError
}

func (c *CallToolResult) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *CallToolResult) UnmarshalJSON(data []byte) error {
	type embed CallToolResult
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CallToolResult(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallToolResult) MarshalJSON() ([]byte, error) {
	type embed CallToolResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *CallToolResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CallToolResultContentItem struct {
	Type         string
	Text         *TextContent
	Image        *ImageContent
	Audio        *AudioContent
	ResourceLink *ResourceLink
	Resource     *EmbeddedResource
}

func NewCallToolResultContentItemFromText(value *TextContent) *CallToolResultContentItem {
	return &CallToolResultContentItem{Type: "text", Text: value}
}

func NewCallToolResultContentItemFromImage(value *ImageContent) *CallToolResultContentItem {
	return &CallToolResultContentItem{Type: "image", Image: value}
}

func NewCallToolResultContentItemFromAudio(value *AudioContent) *CallToolResultContentItem {
	return &CallToolResultContentItem{Type: "audio", Audio: value}
}

func NewCallToolResultContentItemFromResourceLink(value *ResourceLink) *CallToolResultContentItem {
	return &CallToolResultContentItem{Type: "resource_link", ResourceLink: value}
}

func NewCallToolResultContentItemFromResource(value *EmbeddedResource) *CallToolResultContentItem {
	return &CallToolResultContentItem{Type: "resource", Resource: value}
}

func (c *CallToolResultContentItem) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CallToolResultContentItem) GetText() *TextContent {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *CallToolResultContentItem) GetImage() *ImageContent {
	if c == nil {
		return nil
	}
	return c.Image
}

func (c *CallToolResultContentItem) GetAudio() *AudioContent {
	if c == nil {
		return nil
	}
	return c.Audio
}

func (c *CallToolResultContentItem) GetResourceLink() *ResourceLink {
	if c == nil {
		return nil
	}
	return c.ResourceLink
}

func (c *CallToolResultContentItem) GetResource() *EmbeddedResource {
	if c == nil {
		return nil
	}
	return c.Resource
}

func (c *CallToolResultContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(TextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Text = value
	case "image":
		value := new(ImageContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Image = value
	case "audio":
		value := new(AudioContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Audio = value
	case "resource_link":
		value := new(ResourceLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ResourceLink = value
	case "resource":
		value := new(EmbeddedResource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Resource = value
	}
	return nil
}

func (c CallToolResultContentItem) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "text":
		return internal.MarshalJSONWithExtraProperty(c.Text, "type", "text")
	case "image":
		return internal.MarshalJSONWithExtraProperty(c.Image, "type", "image")
	case "audio":
		return internal.MarshalJSONWithExtraProperty(c.Audio, "type", "audio")
	case "resource_link":
		return internal.MarshalJSONWithExtraProperty(c.ResourceLink, "type", "resource_link")
	case "resource":
		return internal.MarshalJSONWithExtraProperty(c.Resource, "type", "resource")
	}
}

type CallToolResultContentItemVisitor interface {
	VisitText(*TextContent) error
	VisitImage(*ImageContent) error
	VisitAudio(*AudioContent) error
	VisitResourceLink(*ResourceLink) error
	VisitResource(*EmbeddedResource) error
}

func (c *CallToolResultContentItem) Accept(visitor CallToolResultContentItemVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "text":
		return visitor.VisitText(c.Text)
	case "image":
		return visitor.VisitImage(c.Image)
	case "audio":
		return visitor.VisitAudio(c.Audio)
	case "resource_link":
		return visitor.VisitResourceLink(c.ResourceLink)
	case "resource":
		return visitor.VisitResource(c.Resource)
	}
}

func (c *CallToolResultContentItem) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Text != nil {
		fields = append(fields, "text")
	}
	if c.Image != nil {
		fields = append(fields, "image")
	}
	if c.Audio != nil {
		fields = append(fields, "audio")
	}
	if c.ResourceLink != nil {
		fields = append(fields, "resource_link")
	}
	if c.Resource != nil {
		fields = append(fields, "resource")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

// The contents of a resource, embedded into a prompt or tool call result.
//
// It is up to the client how best to render embedded resources for the benefit
// of the LLM and/or the user.
type EmbeddedResource struct {
	Resource    *Resource              `json:"resource,omitempty" url:"resource,omitempty"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (e *EmbeddedResource) GetResource() *Resource {
	if e == nil {
		return nil
	}
	return e.Resource
}

func (e *EmbeddedResource) GetAnnotations() *Annotations {
	if e == nil {
		return nil
	}
	return e.Annotations
}

func (e *EmbeddedResource) GetMeta() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Meta
}

func (e *EmbeddedResource) GetExtraProperties() map[string]interface{} {
	return e.ExtraProperties
}

func (e *EmbeddedResource) UnmarshalJSON(data []byte) error {
	type embed EmbeddedResource
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmbeddedResource(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.ExtraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbeddedResource) MarshalJSON() ([]byte, error) {
	type embed EmbeddedResource
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, e.ExtraProperties)
}

func (e *EmbeddedResource) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Image content for a message.
type ImageContent struct {
	Data        string                 `json:"data" url:"data"`
	MimeType    string                 `json:"mimeType" url:"mimeType"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (i *ImageContent) GetData() string {
	if i == nil {
		return ""
	}
	return i.Data
}

func (i *ImageContent) GetMimeType() string {
	if i == nil {
		return ""
	}
	return i.MimeType
}

func (i *ImageContent) GetAnnotations() *Annotations {
	if i == nil {
		return nil
	}
	return i.Annotations
}

func (i *ImageContent) GetMeta() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Meta
}

func (i *ImageContent) GetExtraProperties() map[string]interface{} {
	return i.ExtraProperties
}

func (i *ImageContent) UnmarshalJSON(data []byte) error {
	type embed ImageContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = ImageContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.ExtraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageContent) MarshalJSON() ([]byte, error) {
	type embed ImageContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, i.ExtraProperties)
}

func (i *ImageContent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The server's response to a tools/list request from the client.
type ListToolsResult struct {
	Meta       map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	NextCursor *string                `json:"nextCursor,omitempty" url:"nextCursor,omitempty"`
	Tools      []*Tool                `json:"tools,omitempty" url:"tools,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *ListToolsResult) GetMeta() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.Meta
}

func (l *ListToolsResult) GetNextCursor() *string {
	if l == nil {
		return nil
	}
	return l.NextCursor
}

func (l *ListToolsResult) GetTools() []*Tool {
	if l == nil {
		return nil
	}
	return l.Tools
}

func (l *ListToolsResult) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *ListToolsResult) UnmarshalJSON(data []byte) error {
	type embed ListToolsResult
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = ListToolsResult(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListToolsResult) MarshalJSON() ([]byte, error) {
	type embed ListToolsResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *ListToolsResult) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Resource struct {
	TextResourceContents *TextResourceContents
	BlobResourceContents *BlobResourceContents

	typ string
}

func NewResourceFromTextResourceContents(value *TextResourceContents) *Resource {
	return &Resource{typ: "TextResourceContents", TextResourceContents: value}
}

func NewResourceFromBlobResourceContents(value *BlobResourceContents) *Resource {
	return &Resource{typ: "BlobResourceContents", BlobResourceContents: value}
}

func (r *Resource) GetTextResourceContents() *TextResourceContents {
	if r == nil {
		return nil
	}
	return r.TextResourceContents
}

func (r *Resource) GetBlobResourceContents() *BlobResourceContents {
	if r == nil {
		return nil
	}
	return r.BlobResourceContents
}

func (r *Resource) UnmarshalJSON(data []byte) error {
	valueTextResourceContents := new(TextResourceContents)
	if err := json.Unmarshal(data, &valueTextResourceContents); err == nil {
		r.typ = "TextResourceContents"
		r.TextResourceContents = valueTextResourceContents
		return nil
	}
	valueBlobResourceContents := new(BlobResourceContents)
	if err := json.Unmarshal(data, &valueBlobResourceContents); err == nil {
		r.typ = "BlobResourceContents"
		r.BlobResourceContents = valueBlobResourceContents
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Resource) MarshalJSON() ([]byte, error) {
	if r.typ == "TextResourceContents" || r.TextResourceContents != nil {
		return json.Marshal(r.TextResourceContents)
	}
	if r.typ == "BlobResourceContents" || r.BlobResourceContents != nil {
		return json.Marshal(r.BlobResourceContents)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type ResourceVisitor interface {
	VisitTextResourceContents(*TextResourceContents) error
	VisitBlobResourceContents(*BlobResourceContents) error
}

func (r *Resource) Accept(visitor ResourceVisitor) error {
	if r.typ == "TextResourceContents" || r.TextResourceContents != nil {
		return visitor.VisitTextResourceContents(r.TextResourceContents)
	}
	if r.typ == "BlobResourceContents" || r.BlobResourceContents != nil {
		return visitor.VisitBlobResourceContents(r.BlobResourceContents)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// A resource that the server is capable of reading, included in a prompt or tool call result.
//
// Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
type ResourceLink struct {
	Name        string                 `json:"name" url:"name"`
	Title       *string                `json:"title,omitempty" url:"title,omitempty"`
	Uri         string                 `json:"uri" url:"uri"`
	Description *string                `json:"description,omitempty" url:"description,omitempty"`
	MimeType    *string                `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Size        *int                   `json:"size,omitempty" url:"size,omitempty"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (r *ResourceLink) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *ResourceLink) GetTitle() *string {
	if r == nil {
		return nil
	}
	return r.Title
}

func (r *ResourceLink) GetUri() string {
	if r == nil {
		return ""
	}
	return r.Uri
}

func (r *ResourceLink) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *ResourceLink) GetMimeType() *string {
	if r == nil {
		return nil
	}
	return r.MimeType
}

func (r *ResourceLink) GetSize() *int {
	if r == nil {
		return nil
	}
	return r.Size
}

func (r *ResourceLink) GetAnnotations() *Annotations {
	if r == nil {
		return nil
	}
	return r.Annotations
}

func (r *ResourceLink) GetMeta() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Meta
}

func (r *ResourceLink) GetExtraProperties() map[string]interface{} {
	return r.ExtraProperties
}

func (r *ResourceLink) UnmarshalJSON(data []byte) error {
	type embed ResourceLink
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResourceLink(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.ExtraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceLink) MarshalJSON() ([]byte, error) {
	type embed ResourceLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, r.ExtraProperties)
}

func (r *ResourceLink) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseCallToolResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *CallToolResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseCallToolResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseCallToolResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseCallToolResult) GetData() *CallToolResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseCallToolResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseCallToolResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseCallToolResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseCallToolResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseCallToolResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseListStr struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data []string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseListStr) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseListStr) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseListStr) GetData() []string {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseListStr) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseListStr) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseListStr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseListStr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseListStr) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseListToolsResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *ListToolsResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseListToolsResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseListToolsResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseListToolsResult) GetData() *ListToolsResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseListToolsResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseListToolsResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseListToolsResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseListToolsResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseListToolsResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Text content for a message.
type TextContent struct {
	Text        string                 `json:"text" url:"text"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *TextContent) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TextContent) GetAnnotations() *Annotations {
	if t == nil {
		return nil
	}
	return t.Annotations
}

func (t *TextContent) GetMeta() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *TextContent) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *TextContent) UnmarshalJSON(data []byte) error {
	type embed TextContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextContent) MarshalJSON() ([]byte, error) {
	type embed TextContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, t.ExtraProperties)
}

func (t *TextContent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Text contents of a resource.
type TextResourceContents struct {
	Uri      string                 `json:"uri" url:"uri"`
	MimeType *string                `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Meta     map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	Text     string                 `json:"text" url:"text"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *TextResourceContents) GetUri() string {
	if t == nil {
		return ""
	}
	return t.Uri
}

func (t *TextResourceContents) GetMimeType() *string {
	if t == nil {
		return nil
	}
	return t.MimeType
}

func (t *TextResourceContents) GetMeta() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *TextResourceContents) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TextResourceContents) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *TextResourceContents) UnmarshalJSON(data []byte) error {
	type embed TextResourceContents
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextResourceContents(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextResourceContents) MarshalJSON() ([]byte, error) {
	type embed TextResourceContents
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, t.ExtraProperties)
}

func (t *TextResourceContents) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Definition for a tool the client can call.
type Tool struct {
	Name         string                 `json:"name" url:"name"`
	Title        *string                `json:"title,omitempty" url:"title,omitempty"`
	Description  *string                `json:"description,omitempty" url:"description,omitempty"`
	InputSchema  map[string]interface{} `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	OutputSchema map[string]interface{} `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	Annotations  *ToolAnnotations       `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta         map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *Tool) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *Tool) GetTitle() *string {
	if t == nil {
		return nil
	}
	return t.Title
}

func (t *Tool) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *Tool) GetInputSchema() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.InputSchema
}

func (t *Tool) GetOutputSchema() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.OutputSchema
}

func (t *Tool) GetAnnotations() *ToolAnnotations {
	if t == nil {
		return nil
	}
	return t.Annotations
}

func (t *Tool) GetMeta() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *Tool) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *Tool) UnmarshalJSON(data []byte) error {
	type embed Tool
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Tool(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tool) MarshalJSON() ([]byte, error) {
	type embed Tool
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, t.ExtraProperties)
}

func (t *Tool) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Additional properties describing a Tool to clients.
//
// NOTE: all properties in ToolAnnotations are **hints**.
// They are not guaranteed to provide a faithful description of
// tool behavior (including descriptive properties like `title`).
//
// Clients should never make tool use decisions based on ToolAnnotations
// received from untrusted servers.
type ToolAnnotations struct {
	Title           *string `json:"title,omitempty" url:"title,omitempty"`
	ReadOnlyHint    *bool   `json:"readOnlyHint,omitempty" url:"readOnlyHint,omitempty"`
	DestructiveHint *bool   `json:"destructiveHint,omitempty" url:"destructiveHint,omitempty"`
	IdempotentHint  *bool   `json:"idempotentHint,omitempty" url:"idempotentHint,omitempty"`
	OpenWorldHint   *bool   `json:"openWorldHint,omitempty" url:"openWorldHint,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *ToolAnnotations) GetTitle() *string {
	if t == nil {
		return nil
	}
	return t.Title
}

func (t *ToolAnnotations) GetReadOnlyHint() *bool {
	if t == nil {
		return nil
	}
	return t.ReadOnlyHint
}

func (t *ToolAnnotations) GetDestructiveHint() *bool {
	if t == nil {
		return nil
	}
	return t.DestructiveHint
}

func (t *ToolAnnotations) GetIdempotentHint() *bool {
	if t == nil {
		return nil
	}
	return t.IdempotentHint
}

func (t *ToolAnnotations) GetOpenWorldHint() *bool {
	if t == nil {
		return nil
	}
	return t.OpenWorldHint
}

func (t *ToolAnnotations) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *ToolAnnotations) UnmarshalJSON(data []byte) error {
	type embed ToolAnnotations
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolAnnotations(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolAnnotations) MarshalJSON() ([]byte, error) {
	type embed ToolAnnotations
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, t.ExtraProperties)
}

func (t *ToolAnnotations) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}
