// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
)

type DownloadFileRequest struct {
	Path string `json:"-" url:"path"`
}

type FileFindRequest struct {
	// Directory path to search
	Path string `json:"path" url:"-"`
	// Filename pattern (glob syntax)
	Glob string `json:"glob" url:"-"`
}

type FileListRequest struct {
	// Directory path to list
	Path string `json:"path" url:"-"`
	// Whether to list recursively
	Recursive *bool `json:"recursive,omitempty" url:"-"`
	// Whether to show hidden files
	ShowHidden *bool `json:"show_hidden,omitempty" url:"-"`
	// Filter by file extensions (e.g., ['.py', '.txt'])
	FileTypes []string `json:"file_types,omitempty" url:"-"`
	// Maximum depth for recursive listing
	MaxDepth *int `json:"max_depth,omitempty" url:"-"`
	// Whether to include file size information
	IncludeSize *bool `json:"include_size,omitempty" url:"-"`
	// Whether to include file permissions
	IncludePermissions *bool `json:"include_permissions,omitempty" url:"-"`
	// Sort by: name, size, modified, type
	SortBy *string `json:"sort_by,omitempty" url:"-"`
	// Sort in descending order
	SortDesc *bool `json:"sort_desc,omitempty" url:"-"`
}

type FileReadRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Start line (0-based)
	StartLine *int `json:"start_line,omitempty" url:"-"`
	// End line (not inclusive)
	EndLine *int `json:"end_line,omitempty" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`
}

type FileReplaceRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Original string to replace
	OldStr string `json:"old_str" url:"-"`
	// New string to replace with
	NewStr string `json:"new_str" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`
}

type FileSearchRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Regular expression pattern
	Regex string `json:"regex" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`
}

type StrReplaceEditorRequest struct {
	// The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.
	Command Command `json:"command" url:"-"`
	// Absolute path to file or directory, e.g. `/workspace/file.py` or `/workspace`.
	Path string `json:"path" url:"-"`
	// Required parameter of `create` command, with the content of the file to be created.
	FileText *string `json:"file_text,omitempty" url:"-"`
	// Required parameter of `str_replace` command containing the string in `path` to replace.
	OldStr *string `json:"old_str,omitempty" url:"-"`
	// Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert.
	NewStr *string `json:"new_str,omitempty" url:"-"`
	// Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.
	InsertLine *int `json:"insert_line,omitempty" url:"-"`
	// Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.
	ViewRange []int `json:"view_range,omitempty" url:"-"`
}

// File content encoding type
type FileContentEncoding string

const (
	FileContentEncodingUtf8   FileContentEncoding = "utf-8"
	FileContentEncodingBase64 FileContentEncoding = "base64"
	FileContentEncodingRaw    FileContentEncoding = "raw"
)

func NewFileContentEncodingFromString(s string) (FileContentEncoding, error) {
	switch s {
	case "utf-8":
		return FileContentEncodingUtf8, nil
	case "base64":
		return FileContentEncodingBase64, nil
	case "raw":
		return FileContentEncodingRaw, nil
	}
	var t FileContentEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileContentEncoding) Ptr() *FileContentEncoding {
	return &f
}

// File find result
type FileFindResult struct {
	// Path of the search directory
	Path string `json:"path" url:"path"`
	// List of found files
	Files []string `json:"files,omitempty" url:"files,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileFindResult) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileFindResult) GetFiles() []string {
	if f == nil {
		return nil
	}
	return f.Files
}

func (f *FileFindResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileFindResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileFindResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileFindResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileFindResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File information
type FileInfo struct {
	// File name
	Name string `json:"name" url:"name"`
	// Full file path
	Path string `json:"path" url:"path"`
	// Whether it's a directory
	IsDirectory bool `json:"is_directory" url:"is_directory"`
	// File size in bytes
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Last modified time (ISO format)
	ModifiedTime *string `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// File permissions
	Permissions *string `json:"permissions,omitempty" url:"permissions,omitempty"`
	// File extension
	Extension *string `json:"extension,omitempty" url:"extension,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileInfo) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *FileInfo) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileInfo) GetIsDirectory() bool {
	if f == nil {
		return false
	}
	return f.IsDirectory
}

func (f *FileInfo) GetSize() *int {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *FileInfo) GetModifiedTime() *string {
	if f == nil {
		return nil
	}
	return f.ModifiedTime
}

func (f *FileInfo) GetPermissions() *string {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *FileInfo) GetExtension() *string {
	if f == nil {
		return nil
	}
	return f.Extension
}

func (f *FileInfo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FileInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileInfo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File list result
type FileListResult struct {
	// Listed directory path
	Path string `json:"path" url:"path"`
	// List of files and directories
	Files []*FileInfo `json:"files,omitempty" url:"files,omitempty"`
	// Total number of items
	TotalCount *int `json:"total_count,omitempty" url:"total_count,omitempty"`
	// Number of directories
	DirectoryCount *int `json:"directory_count,omitempty" url:"directory_count,omitempty"`
	// Number of files
	FileCount *int `json:"file_count,omitempty" url:"file_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileListResult) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileListResult) GetFiles() []*FileInfo {
	if f == nil {
		return nil
	}
	return f.Files
}

func (f *FileListResult) GetTotalCount() *int {
	if f == nil {
		return nil
	}
	return f.TotalCount
}

func (f *FileListResult) GetDirectoryCount() *int {
	if f == nil {
		return nil
	}
	return f.DirectoryCount
}

func (f *FileListResult) GetFileCount() *int {
	if f == nil {
		return nil
	}
	return f.FileCount
}

func (f *FileListResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileListResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileListResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileListResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileListResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File read result
type FileReadResult struct {
	// File content
	Content string `json:"content" url:"content"`
	// Path of the read file
	File string `json:"file" url:"file"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileReadResult) GetContent() string {
	if f == nil {
		return ""
	}
	return f.Content
}

func (f *FileReadResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileReadResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileReadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileReadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileReadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileReadResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File content replacement result
type FileReplaceResult struct {
	// Path of the operated file
	File string `json:"file" url:"file"`
	// Number of replacements
	ReplacedCount *int `json:"replaced_count,omitempty" url:"replaced_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileReplaceResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileReplaceResult) GetReplacedCount() *int {
	if f == nil {
		return nil
	}
	return f.ReplacedCount
}

func (f *FileReplaceResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileReplaceResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileReplaceResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileReplaceResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileReplaceResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File content search result
type FileSearchResult struct {
	// Path of the searched file
	File string `json:"file" url:"file"`
	// List of matched content
	Matches []string `json:"matches,omitempty" url:"matches,omitempty"`
	// List of matched line numbers
	LineNumbers []int `json:"line_numbers,omitempty" url:"line_numbers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileSearchResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileSearchResult) GetMatches() []string {
	if f == nil {
		return nil
	}
	return f.Matches
}

func (f *FileSearchResult) GetLineNumbers() []int {
	if f == nil {
		return nil
	}
	return f.LineNumbers
}

func (f *FileSearchResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileSearchResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileSearchResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File upload result
type FileUploadResult struct {
	// Path of the uploaded file
	FilePath string `json:"file_path" url:"file_path"`
	// Size of the uploaded file in bytes
	FileSize int `json:"file_size" url:"file_size"`
	// Whether upload was successful
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileUploadResult) GetFilePath() string {
	if f == nil {
		return ""
	}
	return f.FilePath
}

func (f *FileUploadResult) GetFileSize() int {
	if f == nil {
		return 0
	}
	return f.FileSize
}

func (f *FileUploadResult) GetSuccess() bool {
	if f == nil {
		return false
	}
	return f.Success
}

func (f *FileUploadResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileUploadResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File write result
type FileWriteResult struct {
	// Path of the written file
	File string `json:"file" url:"file"`
	// Number of bytes written
	BytesWritten *int `json:"bytes_written,omitempty" url:"bytes_written,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileWriteResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileWriteResult) GetBytesWritten() *int {
	if f == nil {
		return nil
	}
	return f.BytesWritten
}

func (f *FileWriteResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileWriteResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileWriteResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileWriteResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileWriteResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type ResponseFileFindResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileFindResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileFindResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileFindResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileFindResult) GetData() *FileFindResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileFindResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileFindResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileFindResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileFindResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileFindResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseFileListResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileListResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileListResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileListResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileListResult) GetData() *FileListResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileListResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileListResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileListResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileListResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileListResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseFileReadResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileReadResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileReadResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileReadResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileReadResult) GetData() *FileReadResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileReadResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileReadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileReadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileReadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileReadResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseFileReplaceResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileReplaceResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileReplaceResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileReplaceResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileReplaceResult) GetData() *FileReplaceResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileReplaceResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileReplaceResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileReplaceResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileReplaceResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileReplaceResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseFileSearchResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileSearchResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileSearchResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileSearchResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileSearchResult) GetData() *FileSearchResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileSearchResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileSearchResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileSearchResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseFileUploadResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileUploadResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileUploadResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileUploadResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileUploadResult) GetData() *FileUploadResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileUploadResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileUploadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileUploadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileUploadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileUploadResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseFileWriteResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileWriteResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileWriteResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileWriteResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileWriteResult) GetData() *FileWriteResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileWriteResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileWriteResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileWriteResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileWriteResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileWriteResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseStrReplaceEditorResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *StrReplaceEditorResult `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseStrReplaceEditorResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseStrReplaceEditorResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseStrReplaceEditorResult) GetData() *StrReplaceEditorResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseStrReplaceEditorResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseStrReplaceEditorResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseStrReplaceEditorResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseStrReplaceEditorResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseStrReplaceEditorResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// String replace editor result based on openhands_aci CLIResult
type StrReplaceEditorResult struct {
	// Command execution output
	Output string `json:"output" url:"output"`
	// Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// File path that was operated on
	Path string `json:"path" url:"path"`
	// Whether the file existed before operation
	PrevExist bool `json:"prev_exist" url:"prev_exist"`
	// Previous file content
	OldContent *string `json:"old_content,omitempty" url:"old_content,omitempty"`
	// New file content after operation
	NewContent *string `json:"new_content,omitempty" url:"new_content,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StrReplaceEditorResult) GetOutput() string {
	if s == nil {
		return ""
	}
	return s.Output
}

func (s *StrReplaceEditorResult) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *StrReplaceEditorResult) GetPath() string {
	if s == nil {
		return ""
	}
	return s.Path
}

func (s *StrReplaceEditorResult) GetPrevExist() bool {
	if s == nil {
		return false
	}
	return s.PrevExist
}

func (s *StrReplaceEditorResult) GetOldContent() *string {
	if s == nil {
		return nil
	}
	return s.OldContent
}

func (s *StrReplaceEditorResult) GetNewContent() *string {
	if s == nil {
		return nil
	}
	return s.NewContent
}

func (s *StrReplaceEditorResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StrReplaceEditorResult) UnmarshalJSON(data []byte) error {
	type unmarshaler StrReplaceEditorResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StrReplaceEditorResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StrReplaceEditorResult) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.
type Command string

const (
	CommandView       Command = "view"
	CommandCreate     Command = "create"
	CommandStrReplace Command = "str_replace"
	CommandInsert     Command = "insert"
	CommandUndoEdit   Command = "undo_edit"
)

func NewCommandFromString(s string) (Command, error) {
	switch s {
	case "view":
		return CommandView, nil
	case "create":
		return CommandCreate, nil
	case "str_replace":
		return CommandStrReplace, nil
	case "insert":
		return CommandInsert, nil
	case "undo_edit":
		return CommandUndoEdit, nil
	}
	var t Command
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Command) Ptr() *Command {
	return &c
}

type BodyUploadFile struct {
	Path *string `json:"path,omitempty" url:"-"`
}

type FileWriteRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Content to write (text or base64 encoded for binary)
	Content string `json:"content" url:"-"`
	// Content encoding: utf-8 for text, base64 for binary data
	Encoding *FileContentEncoding `json:"encoding,omitempty" url:"-"`
	// Whether to use append mode
	Append *bool `json:"append,omitempty" url:"-"`
	// Whether to add leading newline (only for text mode)
	LeadingNewline *bool `json:"leading_newline,omitempty" url:"-"`
	// Whether to add trailing newline (only for text mode)
	TrailingNewline *bool `json:"trailing_newline,omitempty" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`
}
